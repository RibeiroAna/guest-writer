---
layout: post
title: "TypeScript from bottom to top - Part 1: Developing an API with Nest.js"
description: "Learn how to use TypeScript to create a Full-stack web application with Angular (frontend) and Nest (backend)"
date: "2018-06-07 08:30"
author:
  name: "Ana Ribeiro"
  url: "https://twitter.com/anacosri"
  mail: "aninhacostaribeiro@gmail.com"
  avatar: "https://twitter.com/anacosri/profile_image?size=original"
design:
  image: https://cdn.auth0.com/blog/nestjs/logo.png
  bg_color: "#090909"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL;DR:** This is a 2-part tutorial series on how to build a Full-stack TypeScript application using Angular 6 and Nest. In part 1, you are going to learn how to build a simple API with Nest.js. Part 2 is going to be about the front end application using Angular.

## What is Nest and why use it with Angular?

[Nest.js](https://docs.nestjs.com/) is one framework of Node.js. What makes it special is that it addresses a problem that no other framework does: the architecture of a Node project. If you have ever tried to build a project using Node.js you may have realized that you can do a lot with one class (for example, a express Middleware can do from authentication to validation) and projects can grow in a confusing way. Nest addresses this problem by creating classes with few (or single) responsibilities.

Another special thing that Nest brings to Node is the possibility to write the project's code in TypeScript (if you have never heard about TypeScript, I would recommend reading [this introduction](https://auth0.com/blog/typescript-practical-introduction/) before reading this article).

[Angular (v2+)](https://angular.io/) is written in TypeScript and Nest is highly inspired by Angular: many components in Nest have the same name in Angular (for example, guards), so that is because we are going to use Angular together Nest in this tutorial (but the back end application built in part 1 is independent from the front end application built in part 2, so you may use your favorite front end framework to consume the endpoints of this API). 

## The app we are building

The app that is going to be created in this tutorial is a simple app of a restaurant's menu, where users may order items online. There are some business rules for this app:

 * Any user can see the items of this menu;
 * Only identified users may add items to a shop cart (order food online); 
 * Only an Admin user may add new items to the menu.  

To keep things simple, we are not going to interact with any external database, nor implement the shop cart functionality.

## Getting started with Nest

To install Nest, first you will need to install Node (v.8.9.0 +) and npm, go to [Node download](https://nodejs.org/en/download/) website and follow the instructions to download and install Node to your operating system (npm comes with node). When it's done, you can check if everything went well by running the following commands:

```bash
node -v # v.8.9.0
npm -v # 5.6.0
```

There are a few ways to start a Nest project, you may check all of them in [Nest documentation](https://docs.nestjs.com/first-steps), here we are going to use `nest-cli` to do so. Run the following commands:

```bash
npm i -g @nestjs/cli # it will install nest-cli
nest new menu # it will create a project called menu
```

If everything went well, you will get by the end of this process a directory called `menu` with the following structure:

```bash
menu
├── README.md
├── nodemon.json
├── package-lock.json
├── package.json
├── src
│   ├── app.controller.spec.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   ├── main.hmr.ts
│   └── main.ts
├── test
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── tsconfig.json
├── tslint.json
└── webpack.config.js
``` 

You can navigate to this directory and type the following to start a server with this project: 

```bash
# watch mode
$ npm run start:dev
```

And then you can visit with in your browser the address `localhost:3000` and you will get a page like the following one: 

![Hello world webpage](https://i.imgur.com/RZEZJVw.png "Hello World Webpage")

Let's go back to the structure of the project. In this tutorial, tests are not going to be created (if you want a part 3 of this tutorial creating tests for this application, please comment below) so you may delete the directory `test` and the file `src/app.controller.spec.ts` (which are test related). The remaining files inside the directory `src` are:

  * `app.controller.ts` and `app.service.ts`: those files are responsible for generating the message _Hello world_ when the endpoint `/` is accessed through the browser. Because this endpoint is not important to this application you may delete those files as well. Soon you are going to learn in more details what are **controllers** and **services**.
  * `app.module.ts`: this is a class of the type **module**, it is responsible for declaring imports,exports, controllers and providers to an application. Every application has at least one module but you may create more than one module for more complex applications (more details on [Nest.js documentation](https://docs.nestjs.com/modules)). The application of this tutorial will have only one main module. 
  * `main.ts`: is responsible for starting the server.
  * `main.hrm.ts`: is a file of type [Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/), it installs modules during the server execution and it is useful for a quicker development.

## Creating endpoints

The most important endpoint to this app is `/items` because from there the items of the menu are going to be retrieved and created, so this is the first endpoint that is going to be implemented. First you should create a directory called `items` inside `src` folder, there all the files related to this endpoint are going to be placed. 

### Creating a controller

 The responsibility of a controller is map endpoints to functionalities, the controllers are indicated by the decorator `@controller(${ENDPOINT_TO_BE_MAPPED}`. The endpoint `/items` is going to accept two http methods, `get` (to retrieve all the items of the menu, marked with the decorator `@get`) and the endpoint `post` (to create new items, marked with the decorator `@post`). The controller for this application is going to be called `items.controller.ts` and is going to look something like that :

```typescript
import {
  Get,
  Post,
  Controller,
} from '@nestjs/common';

@Controller('items')
export class ItemsController {

  @Get()
  async findAll(): Promise<string[]> {
    return ["Pizza", "Coke"];
  }

  @Post()
  async create() {
    return "Not yet implemented"
  }
}
```

Then, you should add this controller to `app.module.ts` file:

```typescript
import { Module } from '@nestjs/common';
import { ItemsController } from './items/items.controller';

@Module({
  imports: [],
  controllers: [ItemsController],
  providers: []
})
export class AppModule {}
```

You may restart the app and access `localhost:3000/items` with your browser and you will get the array `["Pizza", "Coke"]`. 

### Adding a service

The array returned by the application is just a static array that has no manipulation: handling a data structure is not a responsibility of a module class, it is a responsibility of a service class (a class that is responsible for serving the module). This kind of class is marked with the decorator `@Injectable`, meaning that they can be injected to other classes. So we are going to create this service class `items.service.ts` that is going to look like the code bellow:

```typescript
import { Injectable } from '@nestjs/common';

@Injectable()
export class ItemsService {
  private readonly items: string[] = ["Pizza", "Coke"];

  findAll(): string[] {
    return this.items;
  }

  create(item: string) {
    this.items.push(item);
  }
}
```

And then you should change the controller class to use this service:

```typescript
import {
    Get,
    Post,
    Body,
    Controller,
  } from '@nestjs/common';
  import { ItemsService } from './items.service';

  @Controller('items')
  export class ItemsController {

  constructor(private readonly itemsService: ItemsService) {}
  
    @Get()
    async findAll(): Promise<string[]> {
      return this.itemsService.findAll();
    }
  
    @Post()
    async create(@Body('item') item: string) {
      this.itemsService.create(item);
    }
  }
```
The decorator `@Body('item')` inside body function means it will return to the function param `item: string` the equivalent to `req.body['item']`.

The class itemsService is injected through `constructor`. The `private readonly` means that the members of `itemsService` are created in the same location.

Now you can add `itemsService` to the `app.modules.ts`:

```typescript
import { Module } from '@nestjs/common';
import { ItemsController } from './items/items.controller';
import { ItemsService } from './items/items.service';

@Module({
  imports: [],
  controllers: [ItemsController],
  providers: [ItemsService]
})
export class AppModule {}
```

With those changes, you can also try to insert a new item to the array using curl:

```bash
curl --data 'item=salad' localhost:3000/items
```

And if you get `localhost:3000/items`, you will see the recently added item. Our endpoint to items is functional right now. 

### Creating a simple route for shop cart

Now that `/items` is working in a basic way, the endpoint for `/shopcart` is going to be created. Since this functionality is not going to be implemented, it is going to be a simple controller returning text. Create a directory called `shopcart` and inside of it, create `shopcart.controller.ts`

```typescript
import {
  Post,
  Controller,
} from '@nestjs/common';

@Controller('shopcart')
export class ShopcartController {
  @Post()
  async addItem() {
    return "This is a fake service :D";
  }
}
```
And then add this controller to our module.

```typescript
import { Module } from '@nestjs/common';
import { ItemsController } from './items/items.controller';
import { ShopcartController } from './shopcart/shopcart.controller';
import { ItemsService } from './items/items.service';

@Module({
  imports: [],
  controllers: [ItemsController, ShopcartController],
  providers: [ItemsService]
})
export class AppModule {}
```

## Adding a typescript interface for items

Going back to our items service, imagine that you want to keep more than just the name of the item (for instance, let's keep price too, but maybe you would also want to keep an item code, or something more). Can you agree that maybe an array of strings may not be the most ideal structure to handle this data? 

To solve this problem, you could create an array of objects, but it would be harder to keep a coherence among all items of this array (are all the elements of this array going to be a Item?), so creating a typescript interface is the most recommended way. Inside the directory `/items` create `item.interface.ts`:

```typescript
export class Item {
  readonly name: string;
  readonly price: number;
}
```

And then change `items.service.ts` and `items.controller.ts` to use this interface:

```typescript
import { Injectable } from '@nestjs/common';
import { Item } from './item.interface';

@Injectable()
export class ItemsService {
  private readonly items: Item[] = [];

  findAll(): Item[] {
    return this.items;
  }

  create(item: Item) {
    this.items.push(item);
  }
}
```
```typescript
import {
    Get,
    Post,
    Body,
    Controller,
  } from '@nestjs/common';
  import { ItemsService } from './items.service';
  import { Item } from './item.interface';

  @Controller('items')
  export class ItemsController {

  constructor(private readonly itemsService: ItemsService) {}
  
  @Get()
    async findAll(): Promise<Item[]> {
      return this.itemsService.findAll();
    }
  
    @Post()
    async create(@Body('item') item: Item) {
      this.itemsService.create(item);
    }
  }
```

## Adding validation with DTO and Pipes

Although that there is a interface to define a structure to the items array, the application still accepts any kind of element in the post request (you may try to post any object to `/items`). To solve this problem, we are going to create a [DTO (Data Transfer Object)](https://en.wikipedia.org/wiki/Data_transfer_object) together a Pipe. 

A DTO, as the name may makes clear, is an object which main function is define how some data must be transferred among processes. The DTO for items must be created inside the directory items with the name `create-item.dto.ts` and be named like that:

```typescript
import { IsString, IsInt } from 'class-validator';

export class CreateItemDto {
  @IsString() readonly name: string;

  @IsInt() readonly price: number;
}
```

The [Pipe](https://docs.nestjs.com/pipes) is a Nest class that is useful for validation. The pipe we are going to create verifies if the data sent to a method matches its DTO. Because a pipe can be used by several controllers, you should create a directory `common` inside `src` to place the code of the `validation.pipe.ts`, which should look like the following:

```typescript
import { BadRequestException } from '@nestjs/common';
import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  HttpStatus,
} from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value, metadata: ArgumentMetadata) {
    const { metatype } = metadata;
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToClass(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

  private toValidate(metatype): boolean {
    const types = [String, Boolean, Number, Array, Object];
    return !types.find(type => metatype === type);
  }
}
``` 
**Note**: You may have to install `class-validator` and `class-transformer` modules, just type `npm install class-validator class-transformer` on the terminal, inside your project's directory

Now you will have to adapt the  `items.controller.ts` to use this new pipe and the DTO, after doing that, this is how the code of the controller should like:

```typescript
import {
  Get,
  Post,
  Body,
  Controller,
  UsePipes,
} from '@nestjs/common';
import { CreateItemDto } from './create-item.dto';
import { ItemsService } from './items.service';
import { Item } from './item.interface';
import { ValidationPipe } from '../common/validation.pipe';

@Controller('items')
export class ItemsController {
  constructor(private readonly itemsService: ItemsService) {}

  @Get()
  async findAll(): Promise<Item[]> {
    return this.itemsService.findAll();
  }

  @Post()
  @UsePipes(new ValidationPipe())
  async create(@Body() createItemDto: CreateItemDto) {
    this.itemsService.create(createItemDto);
  }
}
```

Now you may run the code and the only type of entry that the endpoint `/item` will accept is something like the following:

```bash
curl \
-H 'Content-Type: application/json' \
-d '{
  "name": "Salad",
  "price": 3
}' http://localhost:3000/items
```

If you try to change the value of `price` for example, to `"invalid"` you will get a 400 bad request error.

## Adding identification with Auth0

One of the requirements of this project is that only identified users could add something to the shopcart and only admin users could add a new product, Auth0 is going to be used for this means.

First you have to create a [free Auth0 account](https://auth0.com/signup), then visit the [API tab](https://manage.auth0.com/#/apis) of the Auth0 manager dashboard and create a new API: 

![API configuration](https://i.imgur.com/kl2IpiD.png "API configuration")
**Important**: the audience should be `http://localhost:3000` (if you choose another one, you will have to change some pieces of code to your chosen address later on) and the signing algorithm **must** be RS256 (if it is another one, the token verification method can be quite different).

Then you should visit the [Applications tab](https://manage.auth0.com/#/applications) of your auth0 manager dashboard, and then click on the application with the same name of the just created API (in my case, "menu"), go to settings and change `Application Type` to `single page application` and add `http://localhost:8080/login` (going to be used later on by our front end) to `Allowed Callback URLs`, you must also copy from this page your _Domain_, _Client ID_ and your _Client Secret_ (going to be used later in this). 

![Application configuration](https://screenshotscdn.firefoxusercontent.com/images/b15bfdea-b630-4594-8976-968fce721a9b.png "Application configuration")

Now, you may try to generate an Auth0 access token, that soon is going to be passed to the application in the request's header. To do that, first visit the following address with your browser:

```bash
https://${YOUR_DOMAIN}/authorize?audience=http://localhost:3000&scope=SCOPE&response_type=code&client_id=${YOUR_CLIENT_ID}&redirect_uri=http://localhost:8080/login&state=STATE?prompt=none
```
Obviously, you should change your username and your client id to those retrieved in the past steps. If everything is correct, you should get the following page:

![Auth0 login page](https://screenshotscdn.firefoxusercontent.com/images/c1fcca54-b321-4c1a-9b36-02ff88ee275f.png "Auth0 login page")

Proceed to login as you would do in any Auth0 application (you may create a new account or use your google account, and then you must give your permission to the application to access your account) and then the page will return to the following address: 

```bash 
http://localhost:8080/login?code=${CODE}&state=${SOME_STATE}
```

Probably, it will be a white page, but you should copy the value returned to `${CODE}` and do the following in a terminal:

```bash
curl --request POST \
  --url 'https://anaribeiro.auth0.com/oauth/token' \
  -H 'content-type: application/json' \
  -d '{
    "grant_type":"authorization_code",
    "client_id": "${YOUR_CLIENT_ID}",
    "client_secret": "${YOUR_CLIENT_SECRET}",
    "code": "${CODE}",
    "redirect_uri": "http://localhost:8080"
    }'
```
If everything was done right, you will get as the answer of this request a JSON object containing the token, the expiration (86400 seconds or 24 hours) and the token type (bearer). In part 2, this process of generating a token is going to be automated by Angular code. Keep the token for the further calls to our API. On the next steps, you are going to learn how to create the code on the API to validate this token.

### A note about express/Nest Middleware

Back to your Auth0 manager dashboard, got to the API that you are working in this example and go to select the tab "quick start". There you are going to see the most indicated way to validate an Auth0 token using Node.

![Quick start code](https://screenshotscdn.firefoxusercontent.com/images/9350d214-86be-43e6-8727-a3ee95e56e5d.png "quick start code")

The `jwtCheck` is of [express Middleware](http://expressjs.com/pt-br/guide/using-middleware.html) type. Nest used to give full support to express Middleware until the v.5 release, where they drop part of the support to express Middleware,according to their own words: to find "a middle-ground between portability and express compatibility.". In Nest.js documentation, the recommended way to create this kind of code (authentication code with a JWT) is with a guard that implements a strategy to validate the token, but validating an Auth0 token that was encrypted with RS256 algorithm is such a hard work, and there is [a tutorial](https://auth0.com/blog/navigating-rs256-and-jwks/) only on that (you may try to create a Nest strategy based on that tutorial). But taking into consideration that the code into `express-jwt` is a tested piece of code, the best way to verify an Auth0 issued token using Nest is still through an express middleware using express directly inside of Nest. 

To implement the solution described previously, first you will need to create a file named `authentication.middleware.ts` inside the directory `common`. The code of this file is going to be an adaptation of the suggested Auth0 node code to TypeScript (it is still a tutorial of using TypeScript from top to bottom), and it will look like that:

```typescript
import { Injectable, NestMiddleware, MiddlewareFunction } from '@nestjs/common';
import * as jwt from 'express-jwt';
import { expressJwtSecret } from 'jwks-rsa';

@Injectable()
export class AuthenticationMiddleware implements NestMiddleware {
  resolve(): MiddlewareFunction {
    return (req, res, next) => {
      jwt({
        secret: expressJwtSecret({
          cache: true,
          rateLimit: true,
          jwksRequestsPerMinute: 5,
          jwksUri: 'https://${DOMAIN}/.well-known/jwks.json',
        }),

        audience: 'http://localhost:3000',
        issuer: 'https://${DOMAIN}/',
        algorithm: 'RS256',
      })(req, res, (err) => {
        if (err) {
          const status = err.status || 500;
          const message = err.message || 'Sorry, we were unable to process your request.';
          return res.status(status).send({
            message,
          });
        }
        next();
      });
    };
  }
}
```
You may will have to install `express-jwt` and `jwks-rsa` (type `node install npm install express-jwt jwks-rsa`), and also change ${DOMAIN} to your domain. Then go to the file `main.ts` and change it to use this middleware in an express server:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { AuthenticationMiddleware } from './common/authentication.middleware';
import * as express from 'express';

async function bootstrap() {
  const server = express();
  const auth = new AuthenticationMiddleware().resolve();
  server.post('/items', auth);
  server.post('/shopcart', auth);

  const app = await NestFactory.create(AppModule, server);
  await app.listen(3000);
}

bootstrap();
```

Now method post of the routes `/items` and `/shopcart` are protected by an Express middleware that verifies if there is a valid Auth0 token together with the call. You may try to do a call like the following:

```bash
curl \
-H 'authorization: Bearer ${TOKEN}'\
-X POST \
http://localhost:3000/shopcart
```

## Adding role authorization with Auth0

Last but not least: the requirement for creating an new item in the menu is being an admin user, and for now, any identified user can post an item. For implementing that, the functionality `roles` of auth0 is going to be used. 

In your Auth0 dashboard, go to [create a new rule](https://manage.auth0.com/#/rules/new) and select "set a new role to an user" model:

![rule page](https://cdn.auth0.com/blog/mean-series/rule-new.jpg "rule page")

And by doing that, you will get a javascript file with a template. You should change a few details in this template to get a functional example. First, the example code is verifying if a user is an admin through its domain email, you may want to change to your email address. Second, the example rule is saving the admin role to an id token, since the token that interests in this example is the one used to access the API resources (an access token), you should also change the id code to an access token. By the end, your code should look like the following one:

```javascript
function (user, context, callback) {
  user.app_metadata = user.app_metadata || {};
  // You can add a Role based on what you want
  // In this case I check domain
  var addRolesToUser = function(user, cb) {
    if (user.email && user.email === '${YOUR_EMAIL}') {
      cb(null, ['admin']);
    } else {
      cb(null, ['user']);
    }
  };

  addRolesToUser(user, function(err, roles) {
    if (err) {
      callback(err);
    } else {
      user.app_metadata.roles = roles;
      auth0.users.updateAppMetadata(user.user_id, user.app_metadata)
        .then(function(){
          context.accessToken['http://localhost:3000/roles'] = user.app_metadata.roles;
          callback(null, user, context);
        })
        .catch(function(err){
          callback(err);
        });
    }
  });
}
```

Then, you should create a Nest guardian that is going to be called `admin.guard.ts` inside the directory `common`. It will be executed after the authentication middleware and will check if in the decoded token there is a field `admin` inside the property `[http://localhost:3000/roles]`. The code should look something like that:

```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';

@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const user = context.args[0].user['http://localhost:3000/roles'];
    if (user.indexOf('admin') > -1) {
      return true;
    } else {
      return false;
    }
  }
}
```
You can redo the login process described in the last topic and if everything went well, you can check if the appropriate role was added to your user account in the [Auth0 Dashboard Users section](https://manage.auth0.com/#/users). Find the user you just logged in with and click the name to view details. This user's Metadata section should now look like this:

![user role admin](https://cdn.auth0.com/blog/mean-series/user-metadata.png "user role admin")

Finally you should change the `items.controller.ts` to use this new guard, by marking the method post with the decorator `@guard`:

```typescript
import {
  Get,
  Post,
  Body,
  Controller,
  UsePipes,
  UseGuards,
  ReflectMetadata,
} from '@nestjs/common';
import { CreateItemDto } from './create-item.dto';
import { ItemsService } from './items.service';
import { Item } from './item.interface';
import { ValidationPipe } from '../common/validation.pipe';
import { AdminGuard } from '../common/admin.guard';

@Controller('items')
export class ItemsController {
  constructor(private readonly itemsService: ItemsService) {}

  @Get()
  async findAll(): Promise<Item[]> {
    return this.itemsService.findAll();
  }

  @Post()
  @UseGuards(new AdminGuard())
  @UsePipes(new ValidationPipe())
  async create(@Body() createItemDto: CreateItemDto) {
    this.itemsService.create(createItemDto);
}
```

Recreate a token for the admin user and try to post an item right now, only admin users can do that:

```bash
curl \
-H 'Content-Type: application/json' \
-H 'authorization: Bearer ${TOKEN}'\
-d '{
  "name": "Salad",
  "price": 3
}' http://localhost:3000/items
```

Congratulations: now you have basic knowledges of Nest.js! You learned here what is a _module_, _controller_, _service_, _interface_, _pipe_, _middleware_ and _guard_! Now you can move on to the next article of the series or read more about Nest on its [documentation](https://docs.nestjs.com).